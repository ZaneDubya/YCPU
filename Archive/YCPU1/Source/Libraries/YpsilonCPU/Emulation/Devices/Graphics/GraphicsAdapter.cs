using System;
using System.Collections.Generic;
using Ypsilon.Emulation.Processor;

namespace Ypsilon.Emulation.Devices.Graphics {
    /// <summary>
    /// Implements the YPSILONTECH Graphics Adapter
    /// </summary>
    public class GraphicsAdapter : ADevice, IMemoryInterface {
        private static readonly byte[] s_DefaultCharset = {
            0x22, 0xE2, 0x00, 0x00, 0x22, 0xF2, 0x00, 0x00, 0x00, 0xF0, 0x22, 0x22, 0x22, 0xE2, 0x22, 0x22,
            0x00, 0xF0, 0x00, 0x00, 0x22, 0xF2, 0x22, 0x22, 0x22, 0x2E, 0x2E, 0x22, 0x55, 0xD5, 0x55, 0x55,
            0x55, 0x1D, 0x0F, 0x00, 0x00, 0x1F, 0x5D, 0x55, 0x55, 0x0D, 0x0F, 0x00, 0x00, 0x0F, 0x5D, 0x55,
            0x55, 0x1D, 0x5D, 0x55, 0x00, 0x0F, 0x0F, 0x00, 0x55, 0x0D, 0x5D, 0x55, 0x22, 0x0F, 0x0F, 0x00,
            0x55, 0xF5, 0x00, 0x00, 0x00, 0x0F, 0x2F, 0x22, 0x00, 0xF0, 0x55, 0x55, 0x55, 0xF5, 0x00, 0x00,
            0x22, 0x2E, 0x0E, 0x00, 0x00, 0x2E, 0x2E, 0x22, 0x00, 0xF0, 0x55, 0x55, 0x55, 0xF5, 0x55, 0x55,
            0x22, 0x2F, 0x2F, 0x22, 0x22, 0x32, 0x00, 0x00, 0x00, 0xE0, 0x22, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
            0x00, 0x00, 0xFF, 0xFF, 0x33, 0x33, 0x33, 0x33, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0xFF, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x02, 0x02, 0x55, 0x00, 0x00, 0x00, 0x50, 0x57, 0x57, 0x00,
            0x72, 0x21, 0x74, 0x02, 0x45, 0x22, 0x12, 0x05, 0x52, 0x25, 0x7D, 0x0C, 0x24, 0x00, 0x00, 0x00,
            0x24, 0x11, 0x21, 0x04, 0x21, 0x44, 0x24, 0x01, 0x50, 0x72, 0x52, 0x00, 0x20, 0x72, 0x22, 0x00,
            0x00, 0x00, 0x20, 0x01, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x44, 0x22, 0x12, 0x01,
            0x52, 0x55, 0x55, 0x02, 0x32, 0x22, 0x22, 0x07, 0x52, 0x24, 0x12, 0x07, 0x52, 0x24, 0x54, 0x02,
            0x55, 0x75, 0x44, 0x04, 0x17, 0x43, 0x54, 0x02, 0x52, 0x31, 0x55, 0x02, 0x47, 0x24, 0x12, 0x01,
            0x52, 0x25, 0x55, 0x02, 0x52, 0x65, 0x54, 0x02, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x01,
            0x48, 0x12, 0x42, 0x08, 0x00, 0x07, 0x07, 0x00, 0x21, 0x84, 0x24, 0x01, 0x52, 0x24, 0x02, 0x02,
            0x52, 0x75, 0x17, 0x06, 0x52, 0x75, 0x55, 0x05, 0x53, 0x35, 0x55, 0x03, 0x52, 0x11, 0x51, 0x02,
            0x53, 0x55, 0x55, 0x03, 0x17, 0x31, 0x11, 0x07, 0x17, 0x31, 0x11, 0x01, 0x52, 0x71, 0x55, 0x02,
            0x55, 0x75, 0x55, 0x05, 0x27, 0x22, 0x22, 0x07, 0x44, 0x44, 0x54, 0x02, 0x55, 0x33, 0x55, 0x05,
            0x11, 0x11, 0x11, 0x07, 0x75, 0x57, 0x55, 0x05, 0x53, 0x55, 0x55, 0x05, 0x52, 0x55, 0x55, 0x02,
            0x53, 0x35, 0x11, 0x01, 0x52, 0x55, 0x55, 0x42, 0x53, 0x35, 0x55, 0x05, 0x52, 0x21, 0x54, 0x02,
            0x27, 0x22, 0x22, 0x02, 0x55, 0x55, 0x55, 0x07, 0x55, 0x55, 0x25, 0x02, 0x55, 0x55, 0x77, 0x05,
            0x55, 0x25, 0x55, 0x05, 0x55, 0x25, 0x22, 0x02, 0x47, 0x24, 0x11, 0x07, 0x26, 0x22, 0x22, 0x06,
            0x11, 0x22, 0x42, 0x04, 0x46, 0x44, 0x44, 0x06, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
            0x42, 0x00, 0x00, 0x00, 0x00, 0x43, 0x56, 0x06, 0x11, 0x53, 0x55, 0x03, 0x00, 0x52, 0x51, 0x02,
            0x44, 0x56, 0x55, 0x06, 0x00, 0x52, 0x17, 0x06, 0x24, 0x72, 0x22, 0x02, 0x00, 0x56, 0x46, 0x03,
            0x11, 0x53, 0x55, 0x05, 0x02, 0x23, 0x22, 0x07, 0x04, 0x44, 0x54, 0x02, 0x11, 0x55, 0x53, 0x05,
            0x23, 0x22, 0x22, 0x07, 0x00, 0x75, 0x57, 0x05, 0x00, 0x53, 0x55, 0x05, 0x00, 0x52, 0x55, 0x02,
            0x00, 0x53, 0x13, 0x01, 0x00, 0x56, 0x46, 0x04, 0x00, 0x53, 0x11, 0x01, 0x00, 0x16, 0x42, 0x03,
            0x20, 0x27, 0x22, 0x04, 0x00, 0x55, 0x55, 0x06, 0x00, 0x55, 0x25, 0x02, 0x00, 0x55, 0x77, 0x05,
            0x00, 0x55, 0x52, 0x05, 0x00, 0x55, 0x46, 0x03, 0x00, 0x47, 0x12, 0x07, 0x24, 0x12, 0x22, 0x04,
            0x22, 0x02, 0x22, 0x02, 0x21, 0x42, 0x22, 0x01, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x22, 0x55, 0x07
        };

        private static readonly byte[] s_DefaultPalette = {
            0x00, 0x00, 0xDA, 0x0F, 0x90, 0x0F, 0x50, 0x08, 0x21, 0x03, 0xD8, 0x01, 0x90, 0x01, 0x42, 0x04,
            0xEF, 0x06, 0x8F, 0x00, 0x6A, 0x00, 0x34, 0x02, 0x5F, 0x08, 0x0D, 0x01, 0xFF, 0x0F, 0x99, 0x09
        };

        // ========================================================================================
        // Internal variables and routines
        private GraphicsMode m_GraphicsMode = GraphicsMode.None;

        private readonly uint[] m_LEMChrRam = new uint[0x80];
        private bool m_LEMChrramChanged;
        private readonly uint[] m_LEMPalRam = new uint[0x10];
        private bool m_LEMPalramChanged;
        private bool m_LEMSelectPage1;

        private bool m_LEMSpritesEnabled;
        private byte[] m_VRAM = new byte[0x02000]; // 8192 b
        protected override ushort DeviceID => 0x0000;
        protected override ushort DeviceRevision => 0x0001;

        // ========================================================================================
        // Implementation of ADevice.
        protected override ushort DeviceType => DeviceTypeGraphicsAdapter;
        protected override ushort ManufacturerID => 0x0000;

        public GraphicsAdapter(YBUS bus)
            : base(bus) {}

        // ========================================================================================
        // Implementation of memory interface.
        public byte this[uint address] {
            get {
                if (address >= m_VRAM.Length)
                    return 0x0000;
                return m_VRAM[address];
            }

            set {
                if (address >= m_VRAM.Length)
                    return;
                m_VRAM[address] = value;
                if (m_GraphicsMode == GraphicsMode.LEM180C || m_GraphicsMode == GraphicsMode.LEM180Plus) {
                    if (address >= 0x0800 && address <= 0x09FF)
                        m_LEMChrramChanged = true;
                    if (address >= 0x0C00 && address <= 0x0C1F)
                        m_LEMPalramChanged = true;
                }
                else {
                    // no other modes written yet
                }
            }
        }

        public override void Display(int busIndex, List<ITexture> textures, IDisplayProvider renderer) {
            switch (m_GraphicsMode) {
                case GraphicsMode.None:
                    // do nothing;
                    return;
                case GraphicsMode.LEM180C:
                case GraphicsMode.LEM180Plus:
                    Update_LEM();
                    ITexture texture = renderer.RenderLEM(busIndex, 32, 12, m_VRAM, m_LEMChrRam, m_LEMPalRam, m_LEMSelectPage1, m_LEMSpritesEnabled);
                    if (texture == null)
                        return;
                    texture.DeviceBusIndex = busIndex;
                    textures.Add(texture);
                    return;
            }
        }

        public override void Dispose() {
            m_VRAM = null;
        }

        public override IMemoryInterface GetMemoryInterface() {
            return this;
        }

        protected override void Initialize() {
            SetMode_None();
        }

        protected override ushort ReceiveMessage(ushort param0, ushort param1) {
            switch (param0) {
                case 0x0000:
                    SetMode_None();
                    return MSG_ACK;
                case 0x0001:
                    SetMode_LEM(GraphicsMode.LEM180C, 0x0000);
                    return MSG_ACK;
                case 0x0002:
                    SetMode_LEM(GraphicsMode.LEM180Plus, param1);
                    return MSG_ACK;
            }
            return MSG_NO_DEVICE;
        }

        private void SetMode_LEM(GraphicsMode mode, ushort param1) {
            m_LEMSelectPage1 = (param1 & 0x0001) != 0;
            m_LEMSpritesEnabled = (param1 & 0x0002) != 0;
            if (m_GraphicsMode == mode)
                return;
            for (uint i = 0; i < 512; i += 1)
                m_VRAM[0x0800 + i] = s_DefaultCharset[i];
            for (uint i = 0; i < 32; i += 1)
                m_VRAM[0x0C00 + i] = s_DefaultPalette[i];
            m_GraphicsMode = mode;
            m_LEMChrramChanged = true;
            m_LEMPalramChanged = true;
        }

        private void SetMode_None() {
            m_GraphicsMode = GraphicsMode.None;
        }

        private void Update_LEM() {
            if (m_LEMChrramChanged) {
                Update_LEM_CHRRAM();
                m_LEMChrramChanged = false;
            }
            if (m_LEMPalramChanged) {
                Update_LEM_PALRAM();
                m_LEMPalramChanged = false;
            }
        }

        private void Update_LEM_CHRRAM() {
            // Assume CHRRAM format is Color (ARGB8888)
            // Each character is 4x8 pixels at 1 bit depth, 4 bytes total.
            // byte 0, bit 0-3: 3210
            // byte 0, bit 4-7: 7654
            // byte 1, bit 0-3: 3210
            // byte 1, bit 4-7: 7654
            // ... same for bytes 2 and 3.
            Buffer.BlockCopy(m_VRAM, 0x0800, m_LEMChrRam, 0, 512);
        }

        private void Update_LEM_PALRAM() {
            // Assume PALRAM format is Color (ARGB8888)
            for (uint i = 0; i < 0x10; i += 1) {
                ushort color = (ushort)(m_VRAM[0x0C00 + i * 2] + (m_VRAM[0x0C00 + i * 2 + 1] << 8));
                m_LEMPalRam[i] = 0xFF000000 | ((uint)(color & 0x0F00) << 12) | ((uint)(color & 0x00F0) << 8) | ((uint)(color & 0x000F) << 4);
            }
        }
    }
}